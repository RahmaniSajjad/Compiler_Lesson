
زمانی که در فرایند تجزیه یک سند، گره‌های AST ساخته می‌شوند، به آن‌ها یک نوع اختصاص داده می‌شود. دستور زبان شکل این نوع و رابطه آن با سایر نوع‌ها را تعیین می‌کند. تمام انواع مدل معنایی زبان شما را تشکیل می‌دهند. دو روش برای استخراج انواع مدل معنایی زبان از دستور زبان وجود دارد که به ترتیب به صورت استنباطی و اعلانی عمل می‌کنند.


همچنین "Inference" یکی از رفتارهای پیش‌فرض در Langium است. در طی ایجاد انواع مدل‌های معنایی، Langium انواع ممکن را مستقیماً از قوانین گرامری استخراج می‌کند. این رویکرد برای زبان‌های ساده و نمونه‌ها بسیار قدرتمند است، اما برای زبان‌های بالغ‌تر توصیه نمی‌شود چرا که تغییرات کوچک در گرامر به سهولت می‌تواند منجر به تغییرات ناسازگار شود.


برای کاهش احتمال تغییرات ناسازگار، Langium انواع معرفی شده را با معرفی انواع اعلام شده (declared types) تعریف می‌کند که توسط کاربر در گرامر با استفاده از یک نحو مانند TypeScript صراحتاً تعریف می‌شوند

در ادامه، جزئیاتی راجع به اینکه چگونه قوانین گرامری با استفاده از استنتاج و اعلام، شکل مدل معنایی را تعیین می‌کنند، توضیح داده می‌شود

## انواع استنتاجی
انواع استنتاجی نتیجه گیری از استفاده Langium از نوع گذاری از قوانین گرامری هستند. بیایید به بررسی اینکه چگونه قوانین مختلف، تعریف این انواع را شکل می‌دهند، نگاهی بیاندازیم:

### قوانین پارسر

ساده‌ترین روش برای نوشتن یک قانون پارسر به شکل زیر است:
```antlr
X: name=ID;
```
با این دستور، Langium نوع گذاری را در زمان پارس کردن قانون استخراج خواهد کرد. به طور معمول، نوع گره بعد از نام قانون نامگذاری می‌شود، که باعث ایجاد این رابط TypeScript در مدل معنایی می‌شود:
```ts
interface X extends AstNode {
    name: string
}
```
همچنین، با استفاده از دستور زیر می‌توان نام رابط را کنترل کرد:
```antlr
X infers MyType: name=ID;
```
که در نتیجه، رابط زیر در مدل معنایی ساخته می‌شود:
```ts
interface MyType extends AstNode {
    name: string
}
```
لطفا توجه کنید که یک interface X دیگر در مدل معنایی وجود ندارد.

مهم است که بفهمید نام قانون بررسی‌کننده و نام نوعی که آن استخراج می‌کند، در دو سطح انتزاعی جداگانه کار می‌کنند. نام قانون بررسی‌کننده در سطح تجزیه استفاده می‌شود که در آن، انواع نادیده گرفته می‌شوند و تنها قانون بررسی‌کننده در نظر گرفته می‌شود، در حالی که نام نوع در سطح انواع استفاده می‌شود که در آن، هم نوع و هم قانون بررسی‌کننده نقش دارند. این بدان معناست که نام نوع می‌تواند بدون تأثیر بر سلسله مراتب قوانین بررسی‌کننده تغییر کند و نام قانون بررسی‌کننده نیز می‌تواند تغییر کند - اگر به طور صریح یک نوع خاص را بررسی یا برگرداند - بدون تأثیر بر مدل زبان برنامه نویسی

با استخراج انواع داخل دستور زبان، امکان تعریف چندین قانون بررسی‌کننده برای ایجاد یک نوع مدل زبانی مشابه نیز وجود دارد. به عنوان مثال، در گرامر زیر، دو قانون X و Y با استخراج یک نوع مدل زبانی واحد MyType وجود دارد:
```antlr
X infers MyType: name=ID;
Y infers MyType: name=ID count=INT;
```
این باعث ایجاد یک رابطه واحد در مدل زبانی می‌شود که دو قانون بررسی‌کننده را با خصوصیات غیرمشترک و اختیاری با یکدیگر 'ادغام' می‌کند:
```ts
interface MyType extends AstNode {
    count?: number
    name: string
}
```

### قوانین ترمینال
قوانین ترمینال با نوع داخلی در مدل زبانی مرتبط هستند. این قوانین به تنهایی منجر به تولید نوع مدل زبانی نمی‌شوند، اما نوع خصوصیات در نوع مدل زبانی که از یک قانون بررسی‌کننده:
```antlr
terminal INT returns number: /[0-9]+/;
terminal ID returns string: /[a-zA-Z_][a-zA-Z0-9_]*/;

X: name=ID count=INT;
```

```ts
// generated interface
interface X extends AstNode {
    name: string
    count: number
}
```

خصوصیت name از نوع string است زیرا قانون پایانی ID به نوع داخلی string مرتبط شده است و خصوصیت count از نوع number است زیرا قانون پایانی INT به نوع داخلی number مرتبط شده است.

### قوانین نوع داده‌ای
قوانین نوع داده‌ای مشابه قوانین پایانی هستند اما در این حالت منجر به ایجاد نوع متغیر برای نوع داخلی در مدل زبانی می‌شوند. به عبارت دیگر، آنها نوع خصوصیات را در نوع مدل زبانی که از یک قانون بررسی‌کننده استخراج می‌شود، تعیین می‌کنند. اما متفاوت از قوانین پایانی، منجر به ایجاد نوع‌های متغیر برای نوع‌های داخلی در مدل زبانی می‌شوند:
```antlr
QualifiedName returns string: ID '.' ID;

X: name=QualifiedName;
```

```ts
// generated types
type QualifiedName = string;

interface X extends AstNode {
    name: string
}
```

### انواع اختصاص‌دهی
سه نوع اختصاص‌دهی در یک قانون بررسی‌کننده در دسترس است:

    = برای اختصاص دادن یک مقدار تکی به یک خصوصیت استفاده می‌شود و منجر به استخراج نوع خصوصیت از سمت راست عملگر شده در اختصاص‌دهی می‌شود.
    += برای اختصاص دادن چند مقدار به یک خصوصیت استفاده می‌شود و منجر به استخراج نوع خصوصیت به عنوان یک آرایه از سمت راست عملگر شده در اختصاص‌دهی می‌شود.
    ?= برای اختصاص دادن یک مقدار منطقی (بولین) به یک خصوصیت استفاده می‌شود و منجر به استخراج نوع خصوصیت به عنوان یک boolean می‌شود.

```antlr
X: name=ID numbers+=INT (numbers+=INT)* isValid?='valid'?;
```

```ts
// generated interface
interface X extends AstNode {
    name: string
    numbers: Array<number>
    isValid: boolean
}
```

در سمت راست یک عبارت از یکی از موارد زیر می‌تواند باشد:

* یک قاعده ترمینالی یا قاعده نوع داده‌ای، که باعث می‌شود نوع ویژگی از نوع داخلی تعیین شود.
* یک قاعده پارسر که باعث می‌شود نوع ویژگی برابر با نوع قاعده پارسر شود.
* یک مرجع متقابل که باعث می‌شود نوع ویژگی به نوع مرجع متقابل اشاره کند.
* یک گزینه، که باعث می‌شود نوع ویژگی برابر با یک اتحاد نوع از تمام انواع موجود در گزینه شود.

```antlr
X: 'x' name=ID;

Y: crossValue=[X:ID] alt=(INT | X | [X:ID]);
```

```ts
// generated types
interface X extends AstNode {
    name: string
}

interface Y extends AstNode {
    crossValue: Reference<X>
    alt: number | X | Reference<X>
}
```

### فراخوانی قوانین اختصاص نیافته

یک قانون پارسر نیازی به داشتن نشانی‌ها ندارد. ممکن است تنها شامل تماس های قانون نشانی نشده باشد. این نوع قوانین می‌توانند برای تغییر سلسله مراتب نوع‌ها استفاده شوند.

```antlr
X: A | B;

A: 'A' name=ID;
B: 'B' name=ID count=INT;

```

```ts
// generated types
type X = A | B;

interface A extends AstNode {
    name: string
}

interface B extends AstNode {
    name: string
    count: number
}
```

### اقدامات ساده

اکشن ها می‌توانند برای تغییر نوع یک گره درون یک قانون پارسر به یک نوع مدل سمتی دیگر استفاده شوند. به عنوان مثال، آنها به شما اجازه می دهند قوانین پارسر را که باید به چندین قانون تقسیم شوند را ساده کنید.

```antlr
X: 
    {infer A} 'A' name=ID 
  | {infer B} 'B' name=ID count=INT;

// is equivalent to:
X: A | B;
A: 'A' name=ID;
B: 'B' name=ID count=INT;
```

```ts
// generated types
type X = A | B;

interface A extends AstNode {
    name: string
}

interface B extends AstNode {
    name: string
    count: number
}
```

### اقدامات تعیین شده

عملیات (Action) ها نیز می توانند برای کنترل ساختار نوع مدل نهایی (Semantic Model) استفاده شوند. در این حالت، از گرامر برای ایجاد نوع مدل نهایی استفاده نمی شود بلکه عملیات متناسب با گرامر تعریف شده، این کار را برای ما انجام می دهد. به عبارت دیگر، از این عملیات برای ایجاد ساختار پیچیده تری در نوع مدل نهایی استفاده می شود که با استفاده از گرامر ممکن نبود آن را توصیف کرد. لذا، بهتر است پیش از ورود به این قسمت، با مستندات دیگر آشنا شوید.

بیایید دو گرامر متفاوت از مثال حسابی [Arithmetics example](https://github.com/langium/langium/blob/main/examples/arithmetics/src/language-server/arithmetics.langium) را مورد بررسی قرار دهیم. این دو گرامر برای پارس کردن یک سند شامل یک تعریف واحد از یک نام و یک مقدار انتساب عبارت هستند، که عبارت می تواند شامل هر تعداد اضافات یا یک مقدار عددی باشد.

اولین مورد از اقدامات اختصاص داده شده استفاده نمی کند:

```antlr
Definition: 
    'def' name=ID ':' expr=Expression;
Expression:
    Addition;
Addition infers Expression:
    left=Value ('+' right=Expression)?;
    
Primary infers Expression:
    '(' Expression ')' | {Literal} value=NUMBER;
```
